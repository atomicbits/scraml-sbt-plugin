package io.atomicbits.scraml.sbtplugin

import java.util.Date

import io.atomicbits.scraml.generator.ScramlGenerator
import org.joda.time.DateTime
import sbt._
import Keys._

/**
 * Created by peter on 31/07/15. 
 */
object ScramlSbtPlugin extends AutoPlugin {

  override def buildSettings: Seq[Setting[_]] = Seq(
    libraryDependencies ++= Seq(
      "io.atomicbits" %% "scraml-dsl" % "0.2.0-SNAPSHOT" withSources() withJavadoc()
    )
  )

  var lastGeneratedFiles: Seq[File] = Seq()

  // by defining autoImport, the settings are automatically imported into user's `*.sbt`
  object autoImport {

    // configuration points, like the built-in `version`, `libraryDependencies`, or `compile`

    // override lazy val projectSettings = Seq(commands += helloCommand)
    val scraml = taskKey[Seq[File]]("scraml generator")
    val scramlRamlApi = settingKey[String]("scraml raml file pointer")
    val scramlApiPackageName = settingKey[String]("API package name for code generated by scraml")
    val scramlApiClassName = settingKey[String]("API class name for code generated by scraml")

    // default values for the tasks and settings
    lazy val baseScramlSettings: Seq[Def.Setting[_]] = Seq(
      scraml := {
        def generate(ramlPointer: String, apiPackageName: String, apiClassName: String, dst: File): Seq[File] = {
          // RAML files are expected to be found in the resource directory
          val ramlBaseDir = resourceDirectory.value
          if (ramlPointer.nonEmpty && apiPackageName.nonEmpty && apiClassName.nonEmpty) {
            if(needsRegeneration(ramlBaseDir, dst)) {
              val ramlSource = new File(ramlBaseDir, ramlPointer)
              val generatedFiles: Seq[(File, String)] =
                ScramlGenerator.generate(s"file://${ramlSource.getCanonicalPath}", apiPackageName, apiClassName)
              dst.mkdirs()
              val files: Seq[File] =
                generatedFiles.map { fileWithContent =>
                  val (file, content) = fileWithContent
                  val fileInDst = new File(dst, file.getCanonicalPath)
                  fileInDst.getParentFile.mkdirs()
                  IO.write(fileInDst, content)
                  fileInDst
                }
              lastGeneratedFiles = files
              files
            } else {
              lastGeneratedFiles
            }
          } else {
            Seq.empty[File]
          }
        }
        generate(
          (scramlRamlApi in scraml).value,
          (scramlApiPackageName in scraml).value,
          (scramlApiClassName in scraml).value,
          sourceManaged.value
        )
      },
      // We can set a default value as below
      //   ramlMain in scraml := "",
      // but to set the value in a project we then need to do:
      //   ramlMain in scraml in Compile := "foo"
      // instead of just:
      //   ramlMain in scraml := "foo"
      sourceGenerators in Compile += (scraml in Compile).taskValue
    )
  }

  import autoImport._

  override def requires = sbt.plugins.JvmPlugin

  // This plugin is automatically enabled for projects that have a JvmPlugin.
  override def trigger = allRequirements

  // a group of settings that are automatically added to projects.
  override val projectSettings =
    inConfig(Compile)(baseScramlSettings)
  // ++ inConfig(Test)(baseScramlSettings)

  var lastModifiedTime: Long = 0L

  private def needsRegeneration(dir: File, destination: File): Boolean = {

    def lastChangedTime(filesAndDirectories: List[File]): Option[Long] = {

      val (files, directories) = filesAndDirectories.partition(_.isFile)

      val maxFilesModifiedTime =
        if (files.nonEmpty) Some(files.map(_.lastModified()).max)
        else None

      val optLastModifiedTimes = maxFilesModifiedTime :: directories.map(dir => lastChangedTime(dir.listFiles().toList))
      val lastModifiedTimes = optLastModifiedTimes.flatten

      if (lastModifiedTimes.nonEmpty) Some(lastModifiedTimes.max)
      else None
    }

    val topLevelFiles =
      if (dir.exists()) dir.listFiles().toList
      else List()

    val destinationEmpty = !destination.exists() || destination.listFiles().toList.isEmpty

    val changedTime = lastChangedTime(topLevelFiles)

    changedTime.exists { changedT =>
      val changed = changedT > lastModifiedTime
      if (changed) lastModifiedTime = changedT
      // If we have resource files and the destination dir is empty, we regenerate anyhow to avoid starvation after a clean operation.
      changed || destinationEmpty
    }

  }

}
